<div id="ucb-visualization-container">
  <h3>Upper Confidence Bound (UCB) Algorithm Visualization</h3>
  <div class="controls">
    <div class="control-group">
      <button id="play-button">Play Simulation</button>
      <div class="step-counter">Step: <span id="step-count">0</span> / 100</div>
    </div>
    <div class="control-group">
      <label for="speed-slider">Speed:</label>
      <input type="range" id="speed-slider" min="10" max="100" value="100" class="slider">
      <span id="speed-value">100%</span>
      <label for="c-parameter">Exploration (c):</label>
      <input type="number" id="c-parameter" min="0.1" step="0.1" value="1.0" class="parameter-input">
    </div>
  </div>
  <div id="chart-wrapper">
    <div id="ucb-chart">
      <!-- Y-axis and grid lines will be generated by JS -->
    </div>
  </div>
  <div class="legend">
    <div class="legend-item"><div class="color-box true-mean"></div> True Mean</div>
    <div class="legend-item"><div class="color-box estimated-mean"></div> Estimated Mean</div>
    <div class="legend-item"><div class="color-box confidence-bounds"></div> UCB Bounds</div>
    <div class="legend-item"><div class="color-box selected"></div> Selected Arm</div>
  </div>
</div>

<style>
#ucb-visualization-container {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif;
  max-width: 900px;
  margin: 20px auto;
  padding: 20px;
  background: #f8f9fa;
  border-radius: 8px;
  box-shadow: 0 2px 10px rgba(0,0,0,0.1);
}

h3 {
  text-align: center;
  margin-top: 0;
  margin-bottom: 20px;
  color: #333;
}

.controls {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
  flex-wrap: wrap;
  gap: 15px;
}

.control-group {
  display: flex;
  align-items: center;
  gap: 10px;
}

#play-button {
  background: #4285f4;
  color: white;
  border: none;
  padding: 10px 20px;
  border-radius: 4px;
  font-size: 16px;
  cursor: pointer;
  transition: background 0.3s;
}

#play-button:hover {
  background: #3367d6;
}

#play-button:disabled {
  background: #ccc;
  cursor: not-allowed;
}

.step-counter {
  font-size: 16px;
  font-weight: 500;
}

.slider {
  width: 120px;
}

.parameter-input {
  width: 60px;
  padding: 5px;
  border: 1px solid #ddd;
  border-radius: 4px;
}

#chart-wrapper {
  position: relative;
  margin-bottom: 20px;
  height: 400px;
  width: 100%;
  border: 1px solid #ddd;
  border-radius: 4px;
  background: white;
}

#ucb-chart {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  overflow: hidden;
}

.y-axis {
  position: absolute;
  left: 0;
  top: 0;
  bottom: 0;
  width: 50px;
  background-color: rgba(250, 250, 250, 0.8);
  border-right: 1px solid #ddd;
  z-index: 10;
}

.y-tick {
  position: absolute;
  left: 0;
  width: 100%;
  height: 1px;
  background-color: #eee;
  z-index: 1;
}

.y-tick-label {
  position: absolute;
  left: 5px;
  transform: translateY(-50%);
  font-size: 12px;
  color: #666;
}

.grid-line {
  position: absolute;
  left: 50px;
  right: 0;
  height: 1px;
  background-color: #f0f0f0;
  z-index: 1;
}

.arm-container {
  position: absolute;
  top: 0;
  bottom: 0;
  z-index: 2;
}

.arm-label {
  position: absolute;
  bottom: 5px;
  text-align: center;
  width: 100%;
  font-weight: bold;
  font-size: 14px;
}

.true-mean-marker {
  position: absolute;
  height: 2px;
  background: #e53935;
  z-index: 4;
}

.estimated-mean-marker {
  position: absolute;
  height: 2px;
  background: #3949ab;
  z-index: 4;
}

.ucb-upper-bound, .ucb-lower-bound {
  position: absolute;
  height: 2px;
  background: rgba(76, 175, 80, 0.8);
  z-index: 3;
  transition: all 0.3s ease-out;
}

.ucb-region {
  position: absolute;
  background: rgba(76, 175, 80, 0.1);
  border-left: 1px dashed rgba(76, 175, 80, 0.5);
  border-right: 1px dashed rgba(76, 175, 80, 0.5);
  z-index: 2;
  transition: all 0.3s ease-out;
}

.ucb-score {
  position: absolute;
  font-size: 11px;
  text-align: center;
  width: 100%;
  color: #4CAF50;
  top: 10px;
  font-weight: bold;
}

.pull-count {
  position: absolute;
  font-size: 11px;
  text-align: center;
  width: 100%;
  bottom: 25px;
}

.selected {
  box-shadow: 0 0 8px rgba(255, 235, 59, 0.6), 0 0 12px rgba(255, 193, 7, 0.6);
  z-index: 10;
  background-color: rgba(255, 248, 225, 0.5);
}

.legend {
  display: flex;
  justify-content: center;
  gap: 20px;
  margin-top: 15px;
  flex-wrap: wrap;
}

.legend-item {
  display: flex;
  align-items: center;
  gap: 5px;
  font-size: 14px;
}

.color-box {
  width: 16px;
  height: 16px;
  border-radius: 3px;
}

.color-box.true-mean {
  background: #e53935;
}

.color-box.estimated-mean {
  background: #3949ab;
}

.color-box.confidence-bounds {
  background: rgba(76, 175, 80, 0.8);
}

.color-box.selected {
  background: #ffc107;
}

.arm-container.selected {
  background-color: rgba(255, 248, 225, 0.5);
  box-shadow: inset 0 0 0 2px #ffc107;
}
</style>

<script>
document.addEventListener('DOMContentLoaded', function() {
  const playButton = document.getElementById('play-button');
  const stepCount = document.getElementById('step-count');
  const chartContainer = document.getElementById('ucb-chart');
  const speedSlider = document.getElementById('speed-slider');
  const speedValue = document.getElementById('speed-value');
  const cParameter = document.getElementById('c-parameter');
  
  // Configuration
  const numArms = 5;
  const maxSteps = 100;
  let c = parseFloat(cParameter.value); // Exploration parameter for UCB
  let playbackSpeed = parseInt(speedSlider.value);
  
  // Chart layout configuration
  const chartPadding = { top: 10, right: 10, bottom: 40, left: 60 };
  
  // Y-axis range configuration
  const yMin = -1;
  const yMax = 3;
  const yRange = yMax - yMin;
  const yAxisTicks = [yMin, 0, 1, 2, yMax]; // Tick marks at -1, 0, 1, 2, 3
  
  // Define the true means of each arm (some close, some far apart)
  const trueMeans = [0.3, 0.4, 0.7, 0.72, 0.35];
  
  // State variables
  let currentStep = 0;
  let isPlaying = false;
  let playInterval = null;
  
  // Event listeners for the controls
  speedSlider.addEventListener('input', function() {
    playbackSpeed = parseInt(this.value);
    speedValue.textContent = `${playbackSpeed}%`;
    
    // If already playing, adjust the speed
    if (isPlaying) {
      clearInterval(playInterval);
      const baseInterval = getIntervalFromSpeed(playbackSpeed, currentStep);
      playInterval = setInterval(runSimulationStep, baseInterval);
    }
  });
  
  cParameter.addEventListener('input', function() {
    const newValue = parseFloat(this.value);
    if (newValue <= 0) {
      this.value = 0.1; // Ensure c is positive
      c = 0.1;
    } else {
      c = newValue;
    }
    
    // Update visualization if we've already started
    if (currentStep > 0) {
      updateVisualization();
    }
  });
  
  // Helper function to calculate interval based on speed
  function getIntervalFromSpeed(speed, step) {
    // Base intervals that we'll scale according to speed
    let baseInterval;
    if (step < 10) {
      baseInterval = 500; // Start slow
    } else if (step < 25) {
      baseInterval = 300; // Medium
    } else if (step < 50) {
      baseInterval = 200; // Faster
    } else {
      baseInterval = 100; // Very fast
    }
    
    // Scale the interval inversely with speed (higher speed = lower interval)
    return Math.floor(baseInterval * (100 / speed));
  }
  
  // Helper function to convert value to Y position in pixels
  function valueToYPixels(value) {
    const availableHeight = chartContainer.clientHeight - chartPadding.top - chartPadding.bottom;
    return chartPadding.top + availableHeight * (1 - (value - yMin) / yRange);
  }
  
  // Helper function to get X position for an arm
  function getArmXPosition(armIndex) {
    const availableWidth = chartContainer.clientWidth - chartPadding.left - chartPadding.right;
    const armWidth = availableWidth / numArms;
    return chartPadding.left + (armIndex * armWidth) + (armWidth / 2);
  }
  
  // Setup the chart area with Y-axis and grid lines
  function setupChart() {
    // Clear any existing elements
    chartContainer.innerHTML = '';
    
    // Create Y-axis
    const yAxis = document.createElement('div');
    yAxis.className = 'y-axis';
    yAxis.style.left = '0';
    yAxis.style.width = `${chartPadding.left}px`;
    chartContainer.appendChild(yAxis);
    
    // Add Y-axis ticks and grid lines
    yAxisTicks.forEach(value => {
      const yPos = valueToYPixels(value);
      
      // Create tick mark on y-axis
      const tick = document.createElement('div');
      tick.className = 'y-tick';
      tick.style.top = `${yPos}px`;
      tick.style.left = '0';
      tick.style.width = `${chartPadding.left}px`;
      
      // Create tick label
      const label = document.createElement('div');
      label.className = 'y-tick-label';
      label.textContent = value.toFixed(1);
      label.style.top = `${yPos}px`;
      
      yAxis.appendChild(tick);
      yAxis.appendChild(label);
      
      // Create grid line
      const gridLine = document.createElement('div');
      gridLine.className = 'grid-line';
      gridLine.style.top = `${yPos}px`;
      gridLine.style.left = `${chartPadding.left}px`;
      chartContainer.appendChild(gridLine);
    });
    
    // Create and position arm containers
    trueMeans.forEach((mean, index) => {
      createArmElements(index, mean);
    });
  }
  
  // Create elements for an arm
  function createArmElements(armIndex, trueMean) {
    const armXCenter = getArmXPosition(armIndex);
    const armWidth = (chartContainer.clientWidth - chartPadding.left - chartPadding.right) / numArms * 0.8;
    const armLeft = armXCenter - (armWidth / 2);
    
    // Create arm container
    const armContainer = document.createElement('div');
    armContainer.className = 'arm-container';
    armContainer.id = `arm-${armIndex}`;
    armContainer.style.left = `${armLeft}px`;
    armContainer.style.width = `${armWidth}px`;
    
    // True mean marker
    const trueMeanMarker = document.createElement('div');
    trueMeanMarker.className = 'true-mean-marker';
    trueMeanMarker.style.width = '100%';
    trueMeanMarker.style.top = `${valueToYPixels(trueMean)}px`;
    armContainer.appendChild(trueMeanMarker);
    
    // Estimated mean marker (initially hidden)
    const estMeanMarker = document.createElement('div');
    estMeanMarker.className = 'estimated-mean-marker';
    estMeanMarker.style.width = '100%';
    estMeanMarker.style.opacity = '0';
    armContainer.appendChild(estMeanMarker);
    
    // Upper UCB bound marker
    const upperBound = document.createElement('div');
    upperBound.className = 'ucb-upper-bound';
    upperBound.style.width = '80%';
    upperBound.style.left = '10%';
    upperBound.style.opacity = '0';
    armContainer.appendChild(upperBound);
    
    // Lower UCB bound marker
    const lowerBound = document.createElement('div');
    lowerBound.className = 'ucb-lower-bound';
    lowerBound.style.width = '80%';
    lowerBound.style.left = '10%';
    lowerBound.style.opacity = '0';
    armContainer.appendChild(lowerBound);
    
    // UCB region (the area between bounds)
    const ucbRegion = document.createElement('div');
    ucbRegion.className = 'ucb-region';
    ucbRegion.style.width = '60%';
    ucbRegion.style.left = '20%';
    ucbRegion.style.opacity = '0';
    armContainer.appendChild(ucbRegion);
    
    // UCB score display
    const ucbScore = document.createElement('div');
    ucbScore.className = 'ucb-score';
    ucbScore.textContent = 'UCB: ?';
    armContainer.appendChild(ucbScore);
    
    // Arm label
    const label = document.createElement('div');
    label.className = 'arm-label';
    label.textContent = `Arm ${armIndex + 1}`;
    armContainer.appendChild(label);
    
    // Pull count display
    const pullCount = document.createElement('div');
    pullCount.className = 'pull-count';
    pullCount.textContent = 'Pulls: 0';
    armContainer.appendChild(pullCount);
    
    chartContainer.appendChild(armContainer);
  }
  
  // Initialize arms data
  const arms = trueMeans.map((mean, index) => ({
    id: index,
    name: `Arm ${index + 1}`,
    trueMean: mean,
    estimatedMean: 0,
    pulls: 0,
    rewards: [],
    ucbValue: Infinity
  }));
  
  // Functions to update the visualization
  function updateVisualization() {
    arms.forEach(arm => {
      const armElement = document.getElementById(`arm-${arm.id}`);
      const estMeanMarker = armElement.querySelector('.estimated-mean-marker');
      const upperBound = armElement.querySelector('.ucb-upper-bound');
      const lowerBound = armElement.querySelector('.ucb-lower-bound');
      const ucbRegion = armElement.querySelector('.ucb-region');
      const ucbScore = armElement.querySelector('.ucb-score');
      const pullCount = armElement.querySelector('.pull-count');
      
      // Update pull count
      pullCount.textContent = `Pulls: ${arm.pulls}`;
      
      if (arm.pulls > 0) {
        // Update estimated mean marker
        estMeanMarker.style.top = `${valueToYPixels(arm.estimatedMean)}px`;
        estMeanMarker.style.opacity = '1';
        
        // Calculate UCB bonus - using current c parameter
        const ucbBonus = c * Math.sqrt(Math.log(currentStep + 1) / arm.pulls);
        
        // Calculate UCB bounds
        const ucbUpper = arm.estimatedMean + ucbBonus;
        const ucbLower = Math.max(yMin, arm.estimatedMean - ucbBonus); // Ensure lower bound doesn't go below yMin
        
        // Position the upper bound marker
        const upperPixels = valueToYPixels(Math.min(yMax, ucbUpper)); // Ensure upper bound doesn't go above yMax
        upperBound.style.top = `${upperPixels}px`;
        upperBound.style.opacity = '1';
        
        // Position the lower bound marker
        const lowerPixels = valueToYPixels(ucbLower);
        lowerBound.style.top = `${lowerPixels}px`;
        lowerBound.style.opacity = '1';
        
        // Update the UCB region
        ucbRegion.style.top = `${upperPixels}px`;
        ucbRegion.style.height = `${lowerPixels - upperPixels}px`;
        ucbRegion.style.opacity = '1';
        
        // Update UCB value for decision making
        arm.ucbValue = ucbUpper;
        
        // Update UCB score display
        ucbScore.textContent = `UCB: ${ucbUpper.toFixed(2)}`;
        
        // // Adjust width of bounds based on certainty
        // // More pulls = more certain = narrower bounds
        // const certaintyFactor = Math.min(0.8, Math.max(0.2, arm.pulls / 20));
        // const boundWidth = 80 - (certaintyFactor * 40);
        // const boundLeftOffset = 10 + (certaintyFactor * 20);
        
        // upperBound.style.width = `${boundWidth}%`;
        // upperBound.style.left = `${boundLeftOffset}%`;
        // lowerBound.style.width = `${boundWidth}%`;
        // lowerBound.style.left = `${boundLeftOffset}%`;
        
        // // Also adjust the region width
        // const regionWidth = Math.max(30, 60 - (certaintyFactor * 30));
        // const regionLeftOffset = 20 + (certaintyFactor * 15);
        // ucbRegion.style.width = `${regionWidth}%`;
        // ucbRegion.style.left = `${regionLeftOffset}%`;
      }
    });
  }
  
  function selectArm() {
    // For first pulls, try each arm once
    if (currentStep < numArms) {
      return arms[currentStep].id;
    }
    
    // Calculate UCB values using current c parameter
    arms.forEach(arm => {
      if (arm.pulls === 0) {
        arm.ucbValue = Infinity; // Ensure unpulled arms are selected first
      } else {
        const ucbBonus = c * Math.sqrt(Math.log(currentStep + 1) / arm.pulls);
        arm.ucbValue = arm.estimatedMean + ucbBonus;
      }
    });
    
    // Select arm with highest UCB value
    let maxUcbValue = -Infinity;
    let selectedArmId = 0;
    
    arms.forEach(arm => {
      if (arm.ucbValue > maxUcbValue) {
        maxUcbValue = arm.ucbValue;
        selectedArmId = arm.id;
      }
    });
    
    return selectedArmId;
  }
  
  function pullArm(armId) {
    const arm = arms[armId];
    
    // Generate reward based on a Bernoulli distribution with the true mean
    const reward = Math.random() < arm.trueMean ? 1 : 0;
    
    // Update arm statistics
    arm.pulls++;
    arm.rewards.push(reward);
    
    // Update estimated mean
    arm.estimatedMean = arm.rewards.reduce((sum, val) => sum + val, 0) / arm.pulls;
    
    // Highlight the selected arm
    arms.forEach(a => {
      const armElement = document.getElementById(`arm-${a.id}`);
      if (a.id === armId) {
        armElement.classList.add('selected');
      } else {
        armElement.classList.remove('selected');
      }
    });
  }
  
  function runSimulationStep() {
    if (currentStep >= maxSteps) {
      stopSimulation();
      return;
    }
    
    // Select arm based on UCB
    const selectedArmId = selectArm();
    
    // Pull the selected arm and get reward
    pullArm(selectedArmId);
    
    // Update visualization
    updateVisualization();
    
    // Increment step
    currentStep++;
    stepCount.textContent = currentStep;
    
    // Adjust animation speed as we progress, taking into account the user's speed setting
    if (isPlaying) {
      clearInterval(playInterval);
      const interval = getIntervalFromSpeed(playbackSpeed, currentStep);
      playInterval = setInterval(runSimulationStep, interval);
    }
  }
  
  function startSimulation() {
    if (isPlaying) return;
    
    isPlaying = true;
    playButton.textContent = 'Pause';
    cParameter.disabled = true; // Disable changing c during simulation
    
    // Run simulation with interval based on speed slider
    const interval = getIntervalFromSpeed(playbackSpeed, currentStep);
    playInterval = setInterval(runSimulationStep, interval);
  }
  
  function pauseSimulation() {
    if (!isPlaying) return;
    
    isPlaying = false;
    clearInterval(playInterval);
    playButton.textContent = 'Resume';
    cParameter.disabled = false; // Allow changing c when paused
  }
  
  function stopSimulation() {
    isPlaying = false;
    clearInterval(playInterval);
    playButton.textContent = 'Reset & Play Again';
    playButton.disabled = false;
    cParameter.disabled = false; // Allow changing c when stopped
  }
  
  function resetSimulation() {
    // Reset all variables
    currentStep = 0;
    stepCount.textContent = currentStep;
    
    // Reset arms data
    arms.forEach(arm => {
      arm.estimatedMean = 0;
      arm.pulls = 0;
      arm.rewards = [];
      arm.ucbValue = Infinity;
      
      const armElement = document.getElementById(`arm-${arm.id}`);
      armElement.classList.remove('selected');
      
      const estMeanMarker = armElement.querySelector('.estimated-mean-marker');
      estMeanMarker.style.opacity = '0';
      
      const upperBound = armElement.querySelector('.ucb-upper-bound');
      upperBound.style.opacity = '0';
      
      const lowerBound = armElement.querySelector('.ucb-lower-bound');
      lowerBound.style.opacity = '0';
      
      const ucbRegion = armElement.querySelector('.ucb-region');
      ucbRegion.style.opacity = '0';
      
      const pullCount = armElement.querySelector('.pull-count');
      pullCount.textContent = 'Pulls: 0';
      
      const ucbScore = armElement.querySelector('.ucb-score');
      ucbScore.textContent = 'UCB: ?';
    });
    
    // Reset button
    playButton.textContent = 'Play Simulation';
  }
  
  // Event listeners
  playButton.addEventListener('click', function() {
    if (currentStep >= maxSteps) {
      resetSimulation();
      startSimulation();
    } else if (isPlaying) {
      pauseSimulation();
    } else {
      startSimulation();
    }
  });
  
  // Initial setup
  window.addEventListener('resize', function() {
    setupChart(); // Redraw chart on window resize
    updateVisualization(); // Update positions
  });
  
  // Run setup once DOM is fully loaded
  setupChart();
  updateVisualization();
});
</script>